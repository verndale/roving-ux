{"version":3,"file":"index.module.js","sources":["../index.js"],"sourcesContent":["const KEYCODE = {\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n};\n\nconst state = new Map();\n\nexport const rovingIndex = ({\n  element: rover,\n  target: selector,\n  callback: cb,\n}) => {\n  // this api allows empty or a query string\n  const target_query = selector || \":scope *\";\n  const targets = rover.querySelectorAll(target_query);\n  const startingPoint = targets[0];\n\n  // take container out of the focus flow\n  rover.tabIndex = -1;\n  // and all the children\n  targets.forEach((a) => (a.tabIndex = -1));\n  // except the first target, that accepts focus\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    active: startingPoint,\n    index: 0,\n  });\n\n  // when container or children get focus\n  const onFocusin = (_) => {\n    if (state.get(\"last_rover\") == rover) return;\n\n    activate(rover, state.get(rover).active);\n    state.set(\"last_rover\", rover);\n  };\n  rover.addEventListener(\"focusin\", onFocusin);\n\n  // watch for arrow keys\n  const onKeydown = (e) => {\n    switch (e.keyCode) {\n      case KEYCODE.RIGHT:\n      case KEYCODE.DOWN:\n        e.preventDefault();\n        focusNextItem(rover, cb);\n        break;\n      case KEYCODE.LEFT:\n      case KEYCODE.UP:\n        e.preventDefault();\n        focusPreviousItem(rover, cb);\n        break;\n      case KEYCODE.HOME:\n        e.preventDefault();\n        focusFirstItem(rover, cb);\n        break;\n      case KEYCODE.END:\n        e.preventDefault();\n        focusLastItem(rover, cb);\n        break;\n    }\n  };\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const cleanup = (_) => {\n    rover.removeEventListener(\"focusin\", onFocusin);\n    rover.removeEventListener(\"keydown\", onKeydown);\n    rover.removeEventListener(\"DOMNodeRemoved\", cleanup);\n\n    state.delete(rover);\n    targets.forEach((a) => (a.tabIndex = \"\"));\n  };\n\n  rover.addEventListener(\"DOMNodeRemovedFromDocument\", cleanup);\n};\n\nconst focusFirstItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // set state index\n  rx.index = 0;\n\n  // use rover index state to find next\n  let first = rx.targets[rx.index];\n\n  // found something, activate it\n  first && activate(rover, first, cb);\n};\n\nconst focusLastItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // set state index\n  rx.index = rx.targets.length - 1;\n\n  // use rover index state to find next\n  let last = rx.targets[rx.index];\n\n  // found something, activate it\n  last && activate(rover, last, cb);\n};\n\nconst focusNextItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // increment state index\n  rx.index += 1;\n\n  // clamp navigation to target bounds\n  if (rx.index > rx.targets.length - 1) rx.index = rx.targets.length - 1;\n\n  // use rover index state to find next\n  let next = rx.targets[rx.index];\n\n  // found something, activate it\n  next && activate(rover, next, cb);\n};\n\nconst focusPreviousItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // decrement from the state index\n  rx.index -= 1;\n\n  // clamp to 0 and above only\n  if (rx.index < 1) rx.index = 0;\n\n  // use rover index state to find next\n  let prev = rx.targets[rx.index];\n\n  // found something, activate it\n  prev && activate(rover, prev, cb);\n};\n\nconst activate = (rover, item, cb) => {\n  const rx = state.get(rover);\n\n  // remove old tab index item\n  rx.active.tabIndex = -1;\n\n  // trigger callback, set new active item and focus it\n  cb && cb(item);\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n};\n"],"names":["state","Map","rovingIndex","rover","element","cb","callback","targets","querySelectorAll","target","startingPoint","tabIndex","forEach","a","set","active","index","onFocusin","_","get","activate","addEventListener","onKeydown","e","keyCode","preventDefault","focusNextItem","focusPreviousItem","focusFirstItem","focusLastItem","cleanup","removeEventListener","rx","first","length","last","next","prev","item","focus"],"mappings":"AAAA,IASMA,EAAQ,IAAIC,IAELC,EAAc,gBAChBC,IAATC,QAEUC,IAAVC,SAIMC,EAAUJ,EAAMK,mBALtBC,QAIiC,YAE3BC,EAAgBH,EAAQ,GAG9BJ,EAAMQ,UAAY,EAElBJ,EAAQK,QAAQ,SAACC,UAAOA,EAAEF,UAAY,IAEtCD,EAAcC,SAAW,EAIzBX,EAAMc,IAAIX,EAAO,CACfI,QAAAA,EACAQ,OAAQL,EACRM,MAAO,IAIT,IAAMC,EAAY,SAACC,GACblB,EAAMmB,IAAI,eAAiBhB,IAE/BiB,EAASjB,EAAOH,EAAMmB,IAAIhB,GAAOY,QACjCf,EAAMc,IAAI,aAAcX,KAE1BA,EAAMkB,iBAAiB,UAAWJ,GAGlC,IAAMK,EAAY,SAACC,GACjB,OAAQA,EAAEC,SACR,KA3CG,GA4CH,KA3CE,GA4CAD,EAAEE,iBACFC,EAAcvB,EAAOE,GACrB,MACF,KAlDE,GAmDF,KAlDA,GAmDEkB,EAAEE,iBACFE,EAAkBxB,EAAOE,GACzB,MACF,KAxDE,GAyDAkB,EAAEE,iBACFG,EAAezB,EAAOE,GACtB,MACF,KA7DC,GA8DCkB,EAAEE,iBACFI,EAAc1B,EAAOE,KAI3BF,EAAMkB,iBAAiB,UAAWC,GAWlCnB,EAAMkB,iBAAiB,6BATP,SAAVS,EAAWZ,GACff,EAAM4B,oBAAoB,UAAWd,GACrCd,EAAM4B,oBAAoB,UAAWT,GACrCnB,EAAM4B,oBAAoB,iBAAkBD,GAE5C9B,SAAaG,GACbI,EAAQK,QAAQ,SAACC,UAAOA,EAAEF,SAAW,QAMnCiB,EAAiB,SAACzB,EAAOE,GAC7B,IAAM2B,EAAKhC,EAAMmB,IAAIhB,GAGrB6B,EAAGhB,MAAQ,EAGX,IAAIiB,EAAQD,EAAGzB,QAAQyB,EAAGhB,OAG1BiB,GAASb,EAASjB,EAAO8B,EAAO5B,IAG5BwB,EAAgB,SAAC1B,EAAOE,GAC5B,IAAM2B,EAAKhC,EAAMmB,IAAIhB,GAGrB6B,EAAGhB,MAAQgB,EAAGzB,QAAQ2B,OAAS,EAG/B,IAAIC,EAAOH,EAAGzB,QAAQyB,EAAGhB,OAGzBmB,GAAQf,EAASjB,EAAOgC,EAAM9B,IAG1BqB,EAAgB,SAACvB,EAAOE,GAC5B,IAAM2B,EAAKhC,EAAMmB,IAAIhB,GAGrB6B,EAAGhB,OAAS,EAGRgB,EAAGhB,MAAQgB,EAAGzB,QAAQ2B,OAAS,IAAGF,EAAGhB,MAAQgB,EAAGzB,QAAQ2B,OAAS,GAGrE,IAAIE,EAAOJ,EAAGzB,QAAQyB,EAAGhB,OAGzBoB,GAAQhB,EAASjB,EAAOiC,EAAM/B,IAG1BsB,EAAoB,SAACxB,EAAOE,GAChC,IAAM2B,EAAKhC,EAAMmB,IAAIhB,GAGrB6B,EAAGhB,OAAS,EAGRgB,EAAGhB,MAAQ,IAAGgB,EAAGhB,MAAQ,GAG7B,IAAIqB,EAAOL,EAAGzB,QAAQyB,EAAGhB,OAGzBqB,GAAQjB,EAASjB,EAAOkC,EAAMhC,IAG1Be,EAAW,SAACjB,EAAOmC,EAAMjC,GAC7B,IAAM2B,EAAKhC,EAAMmB,IAAIhB,GAGrB6B,EAAGjB,OAAOJ,UAAY,EAGtBN,GAAMA,EAAGiC,GACTN,EAAGjB,OAASuB,EACZN,EAAGjB,OAAOJ,SAAW,EACrBqB,EAAGjB,OAAOwB"}