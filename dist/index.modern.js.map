{"version":3,"file":"index.modern.js","sources":["../index.js"],"sourcesContent":["const KEYCODE = {\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n};\n\nconst state = new Map();\n\nexport const rovingIndex = ({\n  element: rover,\n  target: selector,\n  callback: cb,\n}) => {\n  // this api allows empty or a query string\n  const target_query = selector || \":scope *\";\n  const targets = rover.querySelectorAll(target_query);\n  const startingPoint = targets[0];\n\n  // take container out of the focus flow\n  rover.tabIndex = -1;\n  // and all the children\n  targets.forEach((a) => (a.tabIndex = -1));\n  // except the first target, that accepts focus\n  startingPoint.tabIndex = 0;\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    active: startingPoint,\n    index: 0,\n  });\n\n  // when container or children get focus\n  const onFocusin = (_) => {\n    if (state.get(\"last_rover\") == rover) return;\n\n    activate(rover, state.get(rover).active);\n    state.set(\"last_rover\", rover);\n  };\n  rover.addEventListener(\"focusin\", onFocusin);\n\n  // watch for arrow keys\n  const onKeydown = (e) => {\n    switch (e.keyCode) {\n      case KEYCODE.RIGHT:\n      case KEYCODE.DOWN:\n        e.preventDefault();\n        focusNextItem(rover, cb);\n        break;\n      case KEYCODE.LEFT:\n      case KEYCODE.UP:\n        e.preventDefault();\n        focusPreviousItem(rover, cb);\n        break;\n      case KEYCODE.HOME:\n        e.preventDefault();\n        focusFirstItem(rover, cb);\n        break;\n      case KEYCODE.END:\n        e.preventDefault();\n        focusLastItem(rover, cb);\n        break;\n    }\n  };\n  rover.addEventListener(\"keydown\", onKeydown);\n\n  const cleanup = (_) => {\n    rover.removeEventListener(\"focusin\", onFocusin);\n    rover.removeEventListener(\"keydown\", onKeydown);\n    rover.removeEventListener(\"DOMNodeRemoved\", cleanup);\n\n    state.delete(rover);\n    targets.forEach((a) => (a.tabIndex = \"\"));\n  };\n\n  rover.addEventListener(\"DOMNodeRemovedFromDocument\", cleanup);\n};\n\nconst focusFirstItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // set state index\n  rx.index = 0;\n\n  // use rover index state to find next\n  let first = rx.targets[rx.index];\n\n  // found something, activate it\n  next && activate(rover, first, cb);\n};\n\nconst focusLastItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // set state index\n  rx.index = rx.targets.length - 1;\n\n  // use rover index state to find next\n  let last = rx.targets[rx.index];\n\n  // found something, activate it\n  next && activate(rover, last, cb);\n};\n\nconst focusNextItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // increment state index\n  rx.index += 1;\n\n  // clamp navigation to target bounds\n  if (rx.index > rx.targets.length - 1) rx.index = rx.targets.length - 1;\n\n  // use rover index state to find next\n  let next = rx.targets[rx.index];\n\n  // found something, activate it\n  next && activate(rover, next, cb);\n};\n\nconst focusPreviousItem = (rover, cb) => {\n  const rx = state.get(rover);\n\n  // decrement from the state index\n  rx.index -= 1;\n\n  // clamp to 0 and above only\n  if (rx.index < 1) rx.index = 0;\n\n  // use rover index state to find next\n  let prev = rx.targets[rx.index];\n\n  // found something, activate it\n  prev && activate(rover, prev, cb);\n};\n\nconst activate = (rover, item, cb) => {\n  const rx = state.get(rover);\n\n  // remove old tab index item\n  rx.active.tabIndex = -1;\n\n  // trigger callback, set new active item and focus it\n  cb && cb(item);\n  rx.active = item;\n  rx.active.tabIndex = 0;\n  rx.active.focus();\n};\n"],"names":["state","Map","rovingIndex","element","rover","target","selector","callback","cb","targets","querySelectorAll","startingPoint","tabIndex","forEach","a","set","active","index","onFocusin","_","get","activate","addEventListener","onKeydown","e","keyCode","preventDefault","focusNextItem","focusPreviousItem","focusFirstItem","focusLastItem","cleanup","removeEventListener","delete","rx","next","length","prev","item","focus"],"mappings":"AAAA,MASMA,EAAQ,IAAIC,IAELC,EAAc,EACzBC,QAASC,EACTC,OAAQC,EACRC,SAAUC,MAGV,MACMC,EAAUL,EAAMM,iBADDJ,GAAY,YAE3BK,EAAgBF,EAAQ,GAG9BL,EAAMQ,UAAY,EAElBH,EAAQI,QAASC,GAAOA,EAAEF,UAAY,GAEtCD,EAAcC,SAAW,EAIzBZ,EAAMe,IAAIX,EAAO,CACfK,QAAAA,EACAO,OAAQL,EACRM,MAAO,IAIT,MAAMC,EAAaC,IACbnB,EAAMoB,IAAI,eAAiBhB,IAE/BiB,EAASjB,EAAOJ,EAAMoB,IAAIhB,GAAOY,QACjChB,EAAMe,IAAI,aAAcX,KAE1BA,EAAMkB,iBAAiB,UAAWJ,GAGlC,MAAMK,EAAaC,IACjB,OAAQA,EAAEC,SACR,KA3CG,GA4CH,KA3CE,GA4CAD,EAAEE,iBACFC,EAAcvB,EAAOI,GACrB,MACF,KAlDE,GAmDF,KAlDA,GAmDEgB,EAAEE,iBACFE,EAAkBxB,EAAOI,GACzB,MACF,KAxDE,GAyDAgB,EAAEE,iBACFG,EAAezB,EAAOI,GACtB,MACF,KA7DC,GA8DCgB,EAAEE,iBACFI,EAAc1B,EAAOI,KAI3BJ,EAAMkB,iBAAiB,UAAWC,GAElC,MAAMQ,EAAWZ,IACff,EAAM4B,oBAAoB,UAAWd,GACrCd,EAAM4B,oBAAoB,UAAWT,GACrCnB,EAAM4B,oBAAoB,iBAAkBD,GAE5C/B,EAAMiC,OAAO7B,GACbK,EAAQI,QAASC,GAAOA,EAAEF,SAAW,KAGvCR,EAAMkB,iBAAiB,6BAA8BS,IAGjDF,EAAiB,CAACzB,EAAOI,KAC7B,MAAM0B,EAAKlC,EAAMoB,IAAIhB,GAGrB8B,EAAGjB,MAAQ,EAMXkB,MAAQd,EAASjB,EAHL8B,EAAGzB,QAAQyB,EAAGjB,OAGKT,IAG3BsB,EAAgB,CAAC1B,EAAOI,KAC5B,MAAM0B,EAAKlC,EAAMoB,IAAIhB,GAGrB8B,EAAGjB,MAAQiB,EAAGzB,QAAQ2B,OAAS,EAM/BD,MAAQd,EAASjB,EAHN8B,EAAGzB,QAAQyB,EAAGjB,OAGKT,IAG1BmB,EAAgB,CAACvB,EAAOI,KAC5B,MAAM0B,EAAKlC,EAAMoB,IAAIhB,GAGrB8B,EAAGjB,OAAS,EAGRiB,EAAGjB,MAAQiB,EAAGzB,QAAQ2B,OAAS,IAAGF,EAAGjB,MAAQiB,EAAGzB,QAAQ2B,OAAS,GAGrE,IAAID,EAAOD,EAAGzB,QAAQyB,EAAGjB,OAGzBkB,GAAQd,EAASjB,EAAO+B,EAAM3B,IAG1BoB,EAAoB,CAACxB,EAAOI,KAChC,MAAM0B,EAAKlC,EAAMoB,IAAIhB,GAGrB8B,EAAGjB,OAAS,EAGRiB,EAAGjB,MAAQ,IAAGiB,EAAGjB,MAAQ,GAG7B,IAAIoB,EAAOH,EAAGzB,QAAQyB,EAAGjB,OAGzBoB,GAAQhB,EAASjB,EAAOiC,EAAM7B,IAG1Ba,EAAW,CAACjB,EAAOkC,EAAM9B,KAC7B,MAAM0B,EAAKlC,EAAMoB,IAAIhB,GAGrB8B,EAAGlB,OAAOJ,UAAY,EAGtBJ,GAAMA,EAAG8B,GACTJ,EAAGlB,OAASsB,EACZJ,EAAGlB,OAAOJ,SAAW,EACrBsB,EAAGlB,OAAOuB"}